services:
  # Serviço do Banco de Dados PostgreSQL
  postgres-merchant-db:
    image: postgres:15-alpine
    container_name: postgres-merchant-db-container
    environment:
      POSTGRES_USER: merchantuser
      POSTGRES_PASSWORD: merchantpass
      POSTGRES_DB: merchants_db
    ports:
      - "5433:5432"
    volumes:
      - postgres_merchant_data:/var/lib/postgresql/data

  # Serviço da API do Merchant-Service
  merchant-api:
    container_name: merchant-api-container
    build:
      context: ./merchant-service
      dockerfile: Dockerfile
    ports:
      - "3001:3001"
    env_file:
      - ./merchant-service/.env
    depends_on:
      - postgres-merchant-db

  # NOSSO NOVO SERVIÇO DE PAGAMENTOS!
  payment-api:
    container_name: payment-api-container
    build:
      context: ./payment-service # Aponta para a pasta do novo serviço
      dockerfile: Dockerfile
    ports:
      - "3000:3000" # Expõe a porta 3000 que definimos no main.ts
    env_file:
      - ./payment-service/.env # Carrega as variáveis de ambiente dele
    depends_on:
      - postgres-merchant-db # Também depende do banco de dados

  # SERVIÇO: O MESSAGE BROKER!
  rabbitmq:
    image: rabbitmq:3.13-management-alpine # Imagem com a interface de gerenciamento
    container_name: rabbitmq-container
    ports:
      - "5672:5672" # Porta para as aplicações se conectarem
      - "15672:15672" # Porta para a interface web de gerenciamento
    environment:
      RABBITMQ_DEFAULT_USER: guest # Usuário padrão
      RABBITMQ_DEFAULT_PASS: guest # Senha padrão
    
  notification-service:
    container_name: notification-service-container
    build:
      context: ./notification-service # Aponta para a pasta do novo serviço
      dockerfile: Dockerfile
          # Não precisa de 'ports', pois ele só se comunica via RabbitMQ
    depends_on:
        - rabbitmq # Garante que o RabbitMQ inicie antes dele

volumes:
  postgres_merchant_data: